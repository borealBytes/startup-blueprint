parse_and_contextualize:
  description: |
    ⚠️ CRITICAL: You MUST use WorkspaceTool. Returning JSON as text will FAIL this task.

    YOU MUST READ THE DIFF AND COMMIT MESSAGES:

    STEP 1: Call WorkspaceTool(operation="read", filename="diff.txt", content="")
    STEP 2: Call WorkspaceTool(operation="read", filename="commit_messages.txt", content="")

    Apply smart diff sampling strategy:
    - If <100 lines changed: return full diff
    - If 100-500 lines: sample files matching commit intent keywords
    - If >500 lines: sample only high-risk files (auth, db, config, payment, etc.)

    STEP 3: YOU MUST WRITE diff_context.json with this EXACT structure:
    {
      "commit_intent": "summary of what changed (extracted from messages)",
      "total_changes": <number of +/- lines>,
      "changed_files": [
        {
          "path": "file/path.py",
          "type": "modified|added|deleted",
          "additions": <number>,
          "deletions": <number>,
          "risk_level": "high|medium|low"
        }
      ],
      "review_focus_areas": ["security", "database", "config"],
      "sampled_diff": "the filtered/focused diff text (for next agent)"
    }

    ⚠️ MANDATORY - CALL WorkspaceTool:
    You MUST call WorkspaceTool(operation="write", filename="diff_context.json", content=<dict with above structure>)
    The content parameter MUST be a Python dict, NOT a string. WorkspaceTool will auto-convert to JSON.

    ⚠️ WARNING: Returning JSON as your answer without calling WorkspaceTool = TASK FAILURE.
    The ONLY valid task completion is successfully calling WorkspaceTool to write the file.
  expected_output: |
    "Context prepared: N files analyzed, X focus areas identified, diff_context.json written via WorkspaceTool"

detect_code_issues:
  description: |
    ⚠️ MANDATORY: Call WorkspaceTool - DO NOT return analysis as text.

    Using the diff context from the previous agent, detect code issues.

    STEP 1: Call WorkspaceTool(operation="read", filename="diff_context.json", content="")
    Extract the sampled_diff and review_focus_areas

    STEP 2: Scan for issues in ONLY the changed code:
    - Security: SQL injection, hardcoded secrets, eval/exec, auth bypasses
    - Performance: N+1 queries, nested loops, missing pagination
    - Quality: magic numbers, error handling, duplicate code
    - Best practices: debug logging, TODO without tickets, undocumented public APIs

    STEP 3: YOU MUST WRITE code_issues.json with this EXACT structure:
    {
      "critical": [
        {
          "file": "path/to/file.py",
          "line": 42,
          "code_snippet": "the problematic code",
          "description": "what's wrong and why it's critical",
          "severity": "critical"
        }
      ],
      "warnings": [
        {
          "file": "path/to/file.py",
          "line": 100,
          "code_snippet": "the code",
          "description": "what could be improved"
        }
      ],
      "info": [
        {
          "file": "path/to/file.py",
          "line": 200,
          "code_snippet": "the code",
          "description": "informational note"
        }
      ]
    }

    ⚠️ MANDATORY - CALL WorkspaceTool:
    You MUST call WorkspaceTool(operation="write", filename="code_issues.json", content=<dict with above structure>)
    The content parameter MUST be a Python dict, NOT a string. WorkspaceTool will auto-convert to JSON.
    If no issues found, use empty arrays: {"critical": [], "warnings": [], "info": []}

    ⚠️ WARNING: Task fails if you don't use WorkspaceTool to write code_issues.json.
    Returning JSON as text = WRONG. You MUST use the tool.
  expected_output: |
    "Analysis complete: N critical issues, M warnings detected, code_issues.json written via WorkspaceTool"

synthesize_report:
  description: |
    ⚠️ CRITICAL: MUST use WorkspaceTool to write quick_review.json - DO NOT return JSON as text.

    Create the final quick_review.json by synthesizing findings.

    STEP 1: Call WorkspaceTool(operation="read", filename="diff_context.json", content="")
    STEP 2: Call WorkspaceTool(operation="read", filename="code_issues.json", content="")

    STEP 3: Process the findings:
    1. Group similar issues together (same file+line+category)
    2. Rank by severity and impact
    3. Add clear fix_suggestion for each critical/warning
    4. Add positive notes if you see good practices
    5. Decide merge_status: APPROVE, REQUEST_CHANGES, or NEEDS_DISCUSSION

    STEP 4: YOU MUST WRITE quick_review.json with this EXACT structure:
    {
      "status": "ok|warning|critical",
      "summary": "Detailed one-line summary of the review (minimum 100 characters)",
      "total_findings": <number>,
      "critical": [
        {
          "file": "path/to/file.py",
          "line": 42,
          "code_snippet": "the code",
          "description": "what's wrong",
          "fix_suggestion": "how to fix it"
        }
      ],
      "warnings": [
        {
          "file": "path/to/file.py",
          "line": 100,
          "code_snippet": "the code",
          "description": "what could be improved",
          "fix_suggestion": "how to improve it"
        }
      ],
      "info": [
        {
          "file": "path/to/file.py",
          "line": 200,
          "code_snippet": "the code",
          "description": "informational note"
        }
      ],
      "merge_status": "APPROVE|REQUEST_CHANGES|NEEDS_DISCUSSION",
      "merge_rationale": "Detailed explanation of why this merge decision was made"
    }

    ⚠️ MANDATORY - CALL WorkspaceTool:
    You MUST call WorkspaceTool(operation="write", filename="quick_review.json", content=<dict with above structure>)
    The content parameter MUST be a Python dict, NOT a string. WorkspaceTool will auto-convert to JSON.
    - Summary MUST be at least 100 characters long
    - Include ALL findings from code_issues.json (no truncation)
    - merge_status MUST be exactly one of: APPROVE, REQUEST_CHANGES, NEEDS_DISCUSSION
    - If no issues found, use empty arrays but still provide meaningful summary

    ⚠️ WARNING: Returning JSON as answer = TASK FAILURE. 
    You MUST use WorkspaceTool. The ONLY valid completion is calling the tool successfully.
  expected_output: |
    "Review synthesis complete: quick_review.json written via WorkspaceTool with [N] findings"
