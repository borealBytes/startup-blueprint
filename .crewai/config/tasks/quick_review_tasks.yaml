parse_and_contextualize:
  description: |
    YOU MUST READ THE DIFF AND COMMIT MESSAGES:

    STEP 1: Call WorkspaceTool(operation="read", filename="diff.txt", content="")
    STEP 2: Call WorkspaceTool(operation="read", filename="commit_messages.txt", content="")

    Apply smart diff sampling strategy:
    - If <100 lines changed: return full diff
    - If 100-500 lines: sample files matching commit intent keywords
    - If >500 lines: sample only high-risk files (auth, db, config, payment, etc.)

    STEP 3: YOU MUST WRITE diff_context.json with this EXACT structure:
    {
      "commit_intent": "summary of what changed (extracted from messages)",
      "total_changes": <number of +/- lines>,
      "changed_files": [
        {
          "path": "file/path.py",
          "type": "modified|added|deleted",
          "additions": <number>,
          "deletions": <number>,
          "risk_level": "high|medium|low"
        }
      ],
      "review_focus_areas": ["security", "database", "config"],
      "sampled_diff": "the filtered/focused diff text (for next agent)"
    }

    CRITICAL: Call WorkspaceTool(operation="write", filename="diff_context.json", content=<dict with above structure>)
    The content parameter MUST be a Python dict, NOT a string. WorkspaceTool will auto-convert to JSON.
  expected_output: |
    "Context prepared: N files analyzed, X focus areas identified, diff sampled"

detect_code_issues:
  description: |
    Using the diff context from the previous agent, detect code issues.

    STEP 1: Call WorkspaceTool(operation="read", filename="diff_context.json", content="")
    Extract the sampled_diff and review_focus_areas

    STEP 2: Scan for issues in ONLY the changed code:
    - Security: SQL injection, hardcoded secrets, eval/exec, auth bypasses
    - Performance: N+1 queries, nested loops, missing pagination
    - Quality: magic numbers, error handling, duplicate code
    - Best practices: debug logging, TODO without tickets, undocumented public APIs

    STEP 3: YOU MUST WRITE code_issues.json with this EXACT structure:
    {
      "critical": [
        {
          "file": "path/to/file.py",
          "line": 42,
          "code_snippet": "the problematic code",
          "description": "what's wrong and why it's critical",
          "severity": "critical"
        }
      ],
      "warnings": [
        {
          "file": "path/to/file.py",
          "line": 100,
          "code_snippet": "the code",
          "description": "what could be improved"
        }
      ],
      "info": [
        {
          "file": "path/to/file.py",
          "line": 200,
          "code_snippet": "the code",
          "description": "informational note"
        }
      ]
    }

    CRITICAL: Call WorkspaceTool(operation="write", filename="code_issues.json", content=<dict with above structure>)
    The content parameter MUST be a Python dict, NOT a string. WorkspaceTool will auto-convert to JSON.
    If no issues found, use empty arrays: {"critical": [], "warnings": [], "info": []}
  expected_output: |
    "Analysis complete: N critical issues, M warnings detected"

synthesize_report:
  description: |
    Create the final quick_review.json by synthesizing findings.

    STEP 1: Call WorkspaceTool(operation="read", filename="diff_context.json", content="")
    STEP 2: Call WorkspaceTool(operation="read", filename="code_issues.json", content="")

    STEP 3: Process the findings:
    1. Group similar issues together (same file+line+category)
    2. Rank by severity and impact
    3. Add clear fix_suggestion for each critical/warning
    4. Add positive notes if you see good practices
    5. Decide merge_status: APPROVE, REQUEST_CHANGES, or NEEDS_DISCUSSION

    STEP 4: YOU MUST WRITE quick_review.json with this EXACT structure:
    {
      "status": "ok|warning|critical",
      "summary": "Detailed one-line summary of the review (minimum 100 characters)",
      "total_findings": <number>,
      "critical": [
        {
          "file": "path/to/file.py",
          "line": 42,
          "code_snippet": "the code",
          "description": "what's wrong",
          "fix_suggestion": "how to fix it"
        }
      ],
      "warnings": [
        {
          "file": "path/to/file.py",
          "line": 100,
          "code_snippet": "the code",
          "description": "what could be improved",
          "fix_suggestion": "how to improve it"
        }
      ],
      "info": [
        {
          "file": "path/to/file.py",
          "line": 200,
          "code_snippet": "the code",
          "description": "informational note"
        }
      ],
      "merge_status": "APPROVE|REQUEST_CHANGES|NEEDS_DISCUSSION",
      "merge_rationale": "Detailed explanation of why this merge decision was made"
    }

    CRITICAL REQUIREMENTS:
    - Call WorkspaceTool(operation="write", filename="quick_review.json", content=<dict with above structure>)
    - The content parameter MUST be a Python dict, NOT a string. WorkspaceTool will auto-convert to JSON.
    - Summary MUST be at least 100 characters long
    - Include ALL findings from code_issues.json (no truncation)
    - merge_status MUST be exactly one of: APPROVE, REQUEST_CHANGES, NEEDS_DISCUSSION
    - If no issues found, use empty arrays but still provide meaningful summary
  expected_output: |
    "Review synthesis complete: quick_review.json written with [N] findings"
